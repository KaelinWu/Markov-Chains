# -*- coding: utf-8 -*-
"""PLeaseWork.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qIbGIDS1NF_cfY6jUtJdge24aRX3arrS
"""

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import t

def get_stock_data(ticker, start_date, end_date):
    try:
        data = yf.download(ticker, start_date, end_date)
        return data
    except Exception as e:
        return f"Error fetching data: {e}"

ticker_symbol = "XOM"
start_date = "2000-01-01"
end_date = "2025-02-10"
stock_data = get_stock_data(ticker_symbol, start_date, end_date).dropna()
stock_data = stock_data.asfreq('B')  # Set business day frequency

# Calculate daily returns
stock_data['Daily Return'] = stock_data['Close'].pct_change()

# Calculate mean and standard deviation of returns
mean_return = stock_data['Daily Return'].mean()
std_return = stock_data['Daily Return'].std()

thresholds = {
    1.0: mean_return + 1.0 * std_return,
    0.9: mean_return + 0.9 * std_return,
    0.8: mean_return + 0.8 * std_return,
    0.7: mean_return + 0.7 * std_return,
    0.6: mean_return + 0.6 * std_return,
    0.5: mean_return + 0.5 * std_return,
    0.4: mean_return + 0.4 * std_return,
    0.3: mean_return + 0.3 * std_return,
    0.2: mean_return + 0.2 * std_return,
    0.1: mean_return + 0.1 * std_return,
    -0.1: mean_return - 0.1 * std_return,
    -0.2: mean_return - 0.2 * std_return,
    -0.3: mean_return - 0.3 * std_return,
    -0.4: mean_return - 0.4 * std_return,
    -0.5: mean_return - 0.5 * std_return,
    -0.6: mean_return - 0.6 * std_return,
    -0.7: mean_return - 0.7 * std_return,
    -0.8: mean_return - 0.8 * std_return,
    -0.9: mean_return - 0.9 * std_return,
    -1.0: mean_return - 1.0 * std_return,
}

def classify_state(return_value):
    for sigma in sorted(thresholds.keys(), reverse=True):
        if return_value > thresholds[sigma]:
            return f'Up {abs(sigma)}σ'
        elif return_value < thresholds[-sigma if sigma != 0 else sigma]:
            return f'Down {abs(sigma)}σ'
    return 'Stagnant'

# Apply classification
stock_data['Markov State'] = stock_data['Daily Return'].apply(classify_state)
stock_data['Prev State'] = stock_data['Markov State'].shift(1)

# Create transition matrix
transition_counts = pd.crosstab(stock_data['Prev State'], stock_data['Markov State'])
transition_matrix = transition_counts.div(transition_counts.sum(axis=1), axis=0)

# Ensure all states are present in the transition matrix
all_states = sorted(list(thresholds.keys()) + [0], key=lambda x: -x if x > 0 else x)
states = ['Up {:.1f}σ'.format(abs(s)) if s > 0 else ('Down {:.1f}σ'.format(abs(s)) if s < 0 else 'Stagnant') for s in all_states]
transition_matrix = transition_matrix.reindex(index=states, columns=states, fill_value=0)

import yfinance as yf
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from scipy.stats import t

def get_stock_data(ticker, start_date, end_date):
    try:
        data = yf.download(ticker, start_date, end_date)
        return data
    except Exception as e:
        return f"Error fetching data: {e}"

ticker_symbol = "XOM"
start_date = "2000-01-01"
end_date = "2025-02-10"
stock_data = get_stock_data(ticker_symbol, start_date, end_date).dropna()
stock_data = stock_data.asfreq('B')  # Set business day frequency

# Calculate daily returns
stock_data['Daily Return'] = stock_data['Close'].pct_change()

# Calculate mean and standard deviation of returns
mean_return = stock_data['Daily Return'].mean()
std_return = stock_data['Daily Return'].std()

# Define thresholds for classification
thresholds = {
    1.0: mean_return + 1.0 * std_return,
    0.9: mean_return + 0.9 * std_return,
    0.8: mean_return + 0.8 * std_return,
    0.7: mean_return + 0.7 * std_return,
    0.6: mean_return + 0.6 * std_return,
    0.5: mean_return + 0.5 * std_return,
    0.4: mean_return + 0.4 * std_return,
    0.3: mean_return + 0.3 * std_return,
    0.2: mean_return + 0.2 * std_return,
    0.1: mean_return + 0.1 * std_return,
    -0.1: mean_return - 0.1 * std_return,
    -0.2: mean_return - 0.2 * std_return,
    -0.3: mean_return - 0.3 * std_return,
    -0.4: mean_return - 0.4 * std_return,
    -0.5: mean_return - 0.5 * std_return,
    -0.6: mean_return - 0.6 * std_return,
    -0.7: mean_return - 0.7 * std_return,
    -0.8: mean_return - 0.8 * std_return,
    -0.9: mean_return - 0.9 * std_return,
    -1.0: mean_return - 1.0 * std_return,
}

def classify_state(return_value):
    for sigma in sorted(thresholds.keys(), reverse=True):
        if return_value > thresholds[sigma]:
            return f'Up {abs(sigma):.1f}σ'
        elif return_value < thresholds.get(-sigma if sigma != 0 else sigma, -np.inf):
            return f'Down {abs(sigma):.1f}σ'
    return 'Stagnant'

# Apply classification
stock_data['Markov State'] = stock_data['Daily Return'].apply(classify_state)
stock_data['Prev State'] = stock_data['Markov State'].shift(1)

# Create transition matrix
transition_counts = pd.crosstab(stock_data['Prev State'], stock_data['Markov State'])
transition_matrix = transition_counts.div(transition_counts.sum(axis=1), axis=0)

# Ensure all states are present in the transition matrix
all_sigmas = sorted([abs(k) for k in thresholds.keys()] + [0], reverse=True)
states = []
for sigma in all_sigmas:
    if sigma > 0:
        states.append(f'Up {sigma:.1f}σ')
    elif sigma < 0:
        states.append(f'Down {abs(sigma):.1f}σ')
    else:
        states.append('Stagnant')
states = list(dict.fromkeys(states))  # Remove duplicates

# Reindex the transition matrix to include all states
transition_matrix = transition_matrix.reindex(index=states, columns=states, fill_value=0.0)

# Normalize rows to ensure probabilities sum to 1
transition_matrix = transition_matrix.div(transition_matrix.sum(axis=1), axis=0).fillna(0.0)

# Monte Carlo Simulation
n_simulations = 1000
n_days = 252
initial_price = stock_data['Close'].iloc[-1].item()  # Ensure it's a scalar

# Fit Student's t-distribution
params = t.fit(stock_data['Daily Return'].dropna())
df_t, mu, sigma = params

# Simulate paths
simulated_paths = []
for _ in range(n_simulations):
    simulated_returns = []
    current_state = stock_data['Markov State'].iloc[-1]

    for day in range(n_days):
        # Generate return based on current state
        if "Up" in current_state:
            sigma_factor = float(current_state.split(' ')[1].replace('σ', ''))
            daily_return = t.rvs(df_t, loc=mu + sigma_factor * sigma, scale=sigma)
        elif "Down" in current_state:
            sigma_factor = float(current_state.split(' ')[1].replace('σ', ''))
            daily_return = t.rvs(df_t, loc=mu - sigma_factor * sigma, scale=sigma)
        else:
            daily_return = t.rvs(df_t, loc=mu, scale=sigma)

        simulated_returns.append(daily_return)

        # Transition to next state
        if current_state in transition_matrix.index:
            # Ensure probabilities sum to 1
            probs = transition_matrix.loc[current_state].values
            probs = probs / probs.sum()  # Normalize probabilities
            current_state = np.random.choice(
                transition_matrix.columns,
                p=probs
            )
        else:
            # Fallback: choose a state uniformly at random
            current_state = np.random.choice(states)

    # Calculate cumulative returns and prices
    cumulative_returns = np.cumsum(simulated_returns)
    simulated_prices = initial_price * np.exp(cumulative_returns)
    simulated_paths.append(simulated_prices)

# Convert to DataFrame with proper index
dates = pd.date_range(start=stock_data.index[-1], periods=n_days + 1, freq='B')[1:]
simulated_paths_df = pd.DataFrame(simulated_paths, index=dates).T

# Plot results
plt.figure(figsize=(10, 6))
plt.plot(simulated_paths_df, color="lightblue", alpha=0.1)
plt.plot(simulated_paths_df.quantile(0.05, axis=1), color="red", linestyle="--", label="5th Percentile")
plt.plot(simulated_paths_df.quantile(0.95, axis=1), color="green", linestyle="--", label="95th Percentile")
plt.title(f"Markov Chain Monte Carlo Simulation of Stock Close Price ({ticker_symbol})")
plt.xlabel("Date")
plt.ylabel("Price")
plt.legend()
plt.show()